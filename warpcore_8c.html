<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>warpcore: warpcore.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">warpcore
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">warpcore.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;arpa/inet.h&gt;</code><br/>
<code>#include &lt;ifaddrs.h&gt;</code><br/>
<code>#include &lt;netinet/in.h&gt;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;sys/queue.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;net/ethernet.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="warpcore_8h_source.html">warpcore.h</a>&gt;</code><br/>
<code>#include &quot;<a class="el" href="backend_8h_source.html">backend.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="eth_8h_source.html">eth.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ip_8h_source.html">ip.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="udp_8h_source.html">udp.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="version_8h_source.html">version.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for warpcore.c:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c__incl.png" border="0" usemap="#warpcore_8c" alt=""/></div>
<map name="warpcore_8c" id="warpcore_8c">
<area shape="rect" id="node13" href="warpcore_8h.html" title="warpcore.h" alt="" coords="718,155,804,181"/><area shape="rect" id="node21" href="backend_8h.html" title="backend.h" alt="" coords="509,80,591,107"/><area shape="rect" id="node22" href="eth_8h.html" title="eth.h" alt="" coords="309,229,360,256"/><area shape="rect" id="node23" href="ip_8h.html" title="ip.h" alt="" coords="427,155,469,181"/><area shape="rect" id="node24" href="udp_8h.html" title="udp.h" alt="" coords="555,155,609,181"/><area shape="rect" id="node25" href="version_8h.html" title="version.h" alt="" coords="1453,80,1527,107"/><area shape="rect" id="node15" href="plat_8h.html" title="plat.h" alt="" coords="537,229,591,256"/><area shape="rect" id="node16" href="util_8h.html" title="util.h" alt="" coords="819,229,869,256"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58b5813f998352aa600d0415acb49fc5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__iov.html">w_iov</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a58b5813f998352aa600d0415acb49fc5">alloc_iov</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *w)</td></tr>
<tr class="memdesc:a58b5813f998352aa600d0415acb49fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a spare <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> from the pool of the given warpcore engine.  <a href="#a58b5813f998352aa600d0415acb49fc5">More...</a><br/></td></tr>
<tr class="separator:a58b5813f998352aa600d0415acb49fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096e92035238dbb2c6425094c4fdd869"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__sock.html">w_sock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a096e92035238dbb2c6425094c4fdd869">get_sock</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *w, uint16_t port)</td></tr>
<tr class="memdesc:a096e92035238dbb2c6425094c4fdd869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket bound to local port <code>port</code>.  <a href="#a096e92035238dbb2c6425094c4fdd869">More...</a><br/></td></tr>
<tr class="separator:a096e92035238dbb2c6425094c4fdd869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e22b3269944b39e639424a08f4adb"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a3b3e22b3269944b39e639424a08f4adb">alloc_count</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *const w, const uint32_t count, const uint16_t off, const uint16_t adj_last)</td></tr>
<tr class="separator:a3b3e22b3269944b39e639424a08f4adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464c918ca2cf68996ddc0e903128b2ee"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a464c918ca2cf68996ddc0e903128b2ee">w_alloc_size</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *const w, const uint32_t len, const uint16_t off)</td></tr>
<tr class="memdesc:a464c918ca2cf68996ddc0e903128b2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain for <code>len</code> payload bytes, for eventual use with <a class="el" href="warpcore_8c.html#a85274ecaf9a766de49a373c8dec27734" title="Loops over the w_iov structures in the chain c, sending them all over w_sock s. ">w_tx()</a>.  <a href="#a464c918ca2cf68996ddc0e903128b2ee">More...</a><br/></td></tr>
<tr class="separator:a464c918ca2cf68996ddc0e903128b2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307399b989f3d69d8d49516999217336"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a307399b989f3d69d8d49516999217336">w_alloc_count</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *const w, const uint32_t count, const uint16_t off)</td></tr>
<tr class="memdesc:a307399b989f3d69d8d49516999217336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain of <code>count</code> packets, for eventual use with <a class="el" href="warpcore_8c.html#a85274ecaf9a766de49a373c8dec27734" title="Loops over the w_iov structures in the chain c, sending them all over w_sock s. ">w_tx()</a>.  <a href="#a307399b989f3d69d8d49516999217336">More...</a><br/></td></tr>
<tr class="separator:a307399b989f3d69d8d49516999217336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade585dbd786f22b06727ff3a00d62ff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#ade585dbd786f22b06727ff3a00d62ff7">w_free</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *const w, struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const c)</td></tr>
<tr class="memdesc:ade585dbd786f22b06727ff3a00d62ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain obtained via w_alloc() or <a class="el" href="warpcore_8c.html#a56a86a977786ce031b974f17536c1c4e" title="Iterates over any new data in the RX rings, appending them to the w_sock::iv socket buffers of the re...">w_rx()</a> back to warpcore.  <a href="#ade585dbd786f22b06727ff3a00d62ff7">More...</a><br/></td></tr>
<tr class="separator:ade585dbd786f22b06727ff3a00d62ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41497cbbe1bd11e4414a3c42d7f0c2ba"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a41497cbbe1bd11e4414a3c42d7f0c2ba">w_iov_chain_len</a> (const struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const c, const uint16_t off)</td></tr>
<tr class="memdesc:a41497cbbe1bd11e4414a3c42d7f0c2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total payload length of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain <code>c</code>.  <a href="#a41497cbbe1bd11e4414a3c42d7f0c2ba">More...</a><br/></td></tr>
<tr class="separator:a41497cbbe1bd11e4414a3c42d7f0c2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94286f6c75290edeb74f0a499aef1434"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a94286f6c75290edeb74f0a499aef1434">w_iov_chain_cnt</a> (const struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const c)</td></tr>
<tr class="memdesc:a94286f6c75290edeb74f0a499aef1434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain <code>c</code>.  <a href="#a94286f6c75290edeb74f0a499aef1434">More...</a><br/></td></tr>
<tr class="separator:a94286f6c75290edeb74f0a499aef1434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d23fb4fa64de58aef6c688ea6563a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#ab31d23fb4fa64de58aef6c688ea6563a">w_connect</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s, const uint32_t ip, const uint16_t port)</td></tr>
<tr class="memdesc:ab31d23fb4fa64de58aef6c688ea6563a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a bound socket to a remote IP address and port.  <a href="#ab31d23fb4fa64de58aef6c688ea6563a">More...</a><br/></td></tr>
<tr class="separator:ab31d23fb4fa64de58aef6c688ea6563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d8e5b61adc2c9fe1bd32c663a7e23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a07d8e5b61adc2c9fe1bd32c663a7e23f">w_disconnect</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="separator:a07d8e5b61adc2c9fe1bd32c663a7e23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0097edbfdedda7f4a53d85c9f24705"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__sock.html">w_sock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a3d0097edbfdedda7f4a53d85c9f24705">w_bind</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *const w, const uint16_t port, const uint8_t flags)</td></tr>
<tr class="memdesc:a3d0097edbfdedda7f4a53d85c9f24705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to the given local UDP port number.  <a href="#a3d0097edbfdedda7f4a53d85c9f24705">More...</a><br/></td></tr>
<tr class="separator:a3d0097edbfdedda7f4a53d85c9f24705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c31751f7bb602b01bf00077ebd362d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a26c31751f7bb602b01bf00077ebd362d">w_close</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a26c31751f7bb602b01bf00077ebd362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a warpcore socket.  <a href="#a26c31751f7bb602b01bf00077ebd362d">More...</a><br/></td></tr>
<tr class="separator:a26c31751f7bb602b01bf00077ebd362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a86a977786ce031b974f17536c1c4e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a56a86a977786ce031b974f17536c1c4e">w_rx</a> (struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a56a86a977786ce031b974f17536c1c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over any new data in the RX rings, appending them to the <a class="el" href="structw__sock.html#ada65e4fbf06221e7fb73fabd1dd1be8c" title="w_iov chain containing incoming unread data. ">w_sock::iv</a> socket buffers of the respective <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> structures associated with a given sender IPv4 address and port.  <a href="#a56a86a977786ce031b974f17536c1c4e">More...</a><br/></td></tr>
<tr class="separator:a56a86a977786ce031b974f17536c1c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85274ecaf9a766de49a373c8dec27734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a85274ecaf9a766de49a373c8dec27734">w_tx</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s, struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const c)</td></tr>
<tr class="memdesc:a85274ecaf9a766de49a373c8dec27734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops over the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the chain <code>c</code>, sending them all over <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>.  <a href="#a85274ecaf9a766de49a373c8dec27734">More...</a><br/></td></tr>
<tr class="separator:a85274ecaf9a766de49a373c8dec27734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29607b63a6bccf591386fbdabb944bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#ae29607b63a6bccf591386fbdabb944bf">w_cleanup</a> (struct <a class="el" href="structwarpcore.html">warpcore</a> *const w)</td></tr>
<tr class="memdesc:ae29607b63a6bccf591386fbdabb944bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut a warpcore engine down cleanly.  <a href="#ae29607b63a6bccf591386fbdabb944bf">More...</a><br/></td></tr>
<tr class="separator:ae29607b63a6bccf591386fbdabb944bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83867b0dcc2a057772d7d6548a2be00"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwarpcore.html">warpcore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#aa83867b0dcc2a057772d7d6548a2be00">w_init</a> (const char *const ifname, const uint32_t rip)</td></tr>
<tr class="memdesc:aa83867b0dcc2a057772d7d6548a2be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a warpcore engine on the given interface.  <a href="#aa83867b0dcc2a057772d7d6548a2be00">More...</a><br/></td></tr>
<tr class="separator:aa83867b0dcc2a057772d7d6548a2be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419f620e2d1e04c34b248a6874004a0f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwarpcore.html">warpcore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a419f620e2d1e04c34b248a6874004a0f">w_engine</a> (const struct <a class="el" href="structw__sock.html">w_sock</a> *const s)</td></tr>
<tr class="memdesc:a419f620e2d1e04c34b248a6874004a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return warpcore engine serving <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>.  <a href="#a419f620e2d1e04c34b248a6874004a0f">More...</a><br/></td></tr>
<tr class="separator:a419f620e2d1e04c34b248a6874004a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de95626b431e277ef91938501adea5f"><td class="memItemLeft" align="right" valign="top">struct w_sock_chain *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#a9de95626b431e277ef91938501adea5f">w_rx_ready</a> (const struct <a class="el" href="structwarpcore.html">warpcore</a> *w)</td></tr>
<tr class="memdesc:a9de95626b431e277ef91938501adea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a w_sock_chain containing all sockets with pending inbound data.  <a href="#a9de95626b431e277ef91938501adea5f">More...</a><br/></td></tr>
<tr class="separator:a9de95626b431e277ef91938501adea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8a584953993df015ec032271c66f19"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#aae8a584953993df015ec032271c66f19">w_iov_max_len</a> (const struct <a class="el" href="structwarpcore.html">warpcore</a> *const w, const struct <a class="el" href="structw__iov.html">w_iov</a> *const v)</td></tr>
<tr class="memdesc:aae8a584953993df015ec032271c66f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum size a given <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> may have for the given engine.  <a href="#aae8a584953993df015ec032271c66f19">More...</a><br/></td></tr>
<tr class="separator:aae8a584953993df015ec032271c66f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac5f4812d2c339c6d0fa6e591bf555caf"><td class="memItemLeft" align="right" valign="top">struct w_engines&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="warpcore_8c.html#ac5f4812d2c339c6d0fa6e591bf555caf">engines</a> = SLIST_HEAD_INITIALIZER(engines)</td></tr>
<tr class="memdesc:ac5f4812d2c339c6d0fa6e591bf555caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global list of netmap engines that have been initialized for different interfaces.  <a href="#ac5f4812d2c339c6d0fa6e591bf555caf">More...</a><br/></td></tr>
<tr class="separator:ac5f4812d2c339c6d0fa6e591bf555caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3b3e22b3269944b39e639424a08f4adb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a>* alloc_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>adj_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_a3b3e22b3269944b39e639424a08f4adb_cgraph.png" border="0" usemap="#warpcore_8c_a3b3e22b3269944b39e639424a08f4adb_cgraph" alt=""/></div>
<map name="warpcore_8c_a3b3e22b3269944b39e639424a08f4adb_cgraph" id="warpcore_8c_a3b3e22b3269944b39e639424a08f4adb_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a58b5813f998352aa600d0415acb49fc5" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="142,5,215,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a58b5813f998352aa600d0415acb49fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__iov.html">w_iov</a>* alloc_iov </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a spare <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> from the pool of the given warpcore engine. </p>
<p>Needs to be returned via STAILQ_INSERT_HEAD(&amp;w-&gt;iov, v, next).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Warpcore engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Spare <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a096e92035238dbb2c6425094c4fdd869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__sock.html">w_sock</a>* get_sock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the socket bound to local port <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Warpcore engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The port number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> bound to <code>port</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a307399b989f3d69d8d49516999217336"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a>* w_alloc_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain of <code>count</code> packets, for eventual use with <a class="el" href="warpcore_8c.html#a85274ecaf9a766de49a373c8dec27734" title="Loops over the w_iov structures in the chain c, sending them all over w_sock s. ">w_tx()</a>. </p>
<p>Must be later freed with <a class="el" href="warpcore_8c.html#ade585dbd786f22b06727ff3a00d62ff7" title="Return a w_iov chain obtained via w_alloc() or w_rx() back to warpcore. ">w_free()</a>. If a <code>off</code> offset is specified, leave this much extra space before <code>buf</code> in each <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. This is meant for upper-level protocols that wish to reserve space for their headers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Warpcore engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of packets in the returned chain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>Additional offset for <code>buf</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chain of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_a307399b989f3d69d8d49516999217336_cgraph.png" border="0" usemap="#warpcore_8c_a307399b989f3d69d8d49516999217336_cgraph" alt=""/></div>
<map name="warpcore_8c_a307399b989f3d69d8d49516999217336_cgraph" id="warpcore_8c_a307399b989f3d69d8d49516999217336_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a3b3e22b3269944b39e639424a08f4adb" title="alloc_count" alt="" coords="160,5,248,32"/><area shape="rect" id="node3" href="warpcore_8c.html#a58b5813f998352aa600d0415acb49fc5" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="297,5,370,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a464c918ca2cf68996ddc0e903128b2ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a>* w_alloc_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain for <code>len</code> payload bytes, for eventual use with <a class="el" href="warpcore_8c.html#a85274ecaf9a766de49a373c8dec27734" title="Loops over the w_iov structures in the chain c, sending them all over w_sock s. ">w_tx()</a>. </p>
<p>Must be later freed with <a class="el" href="warpcore_8c.html#ade585dbd786f22b06727ff3a00d62ff7" title="Return a w_iov chain obtained via w_alloc() or w_rx() back to warpcore. ">w_free()</a>. If a <code>off</code> offset is specified, leave this much extra space before <code>buf</code> in each <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a>. This is meant for upper-level protocols that wish to reserve space for their headers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>Warpcore engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Amount of payload bytes in the returned chain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>Additional offset for <code>buf</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chain of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ping_8c-example.html#a12">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_a464c918ca2cf68996ddc0e903128b2ee_cgraph.png" border="0" usemap="#warpcore_8c_a464c918ca2cf68996ddc0e903128b2ee_cgraph" alt=""/></div>
<map name="warpcore_8c_a464c918ca2cf68996ddc0e903128b2ee_cgraph" id="warpcore_8c_a464c918ca2cf68996ddc0e903128b2ee_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a3b3e22b3269944b39e639424a08f4adb" title="alloc_count" alt="" coords="152,5,240,32"/><area shape="rect" id="node3" href="warpcore_8c.html#a58b5813f998352aa600d0415acb49fc5" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="289,5,362,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3d0097edbfdedda7f4a53d85c9f24705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__sock.html">w_sock</a>* w_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to the given local UDP port number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">w</td><td>The <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to bind. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The local port number to bind to, in network byte order. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags for this socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a bound <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a7">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a7">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_a3d0097edbfdedda7f4a53d85c9f24705_cgraph.png" border="0" usemap="#warpcore_8c_a3d0097edbfdedda7f4a53d85c9f24705_cgraph" alt=""/></div>
<map name="warpcore_8c_a3d0097edbfdedda7f4a53d85c9f24705_cgraph" id="warpcore_8c_a3d0097edbfdedda7f4a53d85c9f24705_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a096e92035238dbb2c6425094c4fdd869" title="Get the socket bound to local port port. " alt="" coords="132,5,207,32"/><area shape="rect" id="node3" href="backend_8h.html#a7ee48b1b41c1c5293f7cca261794b338" title="Netmap&#45;specific code to bind a warpcore socket. " alt="" coords="118,56,221,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae29607b63a6bccf591386fbdabb944bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_cleanup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut a warpcore engine down cleanly. </p>
<p>In addition to calling into the backend-specific cleanup function, it frees up the extra buffers and other memory structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Warpcore engine. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a24">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a27">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_ae29607b63a6bccf591386fbdabb944bf_cgraph.png" border="0" usemap="#warpcore_8c_ae29607b63a6bccf591386fbdabb944bf_cgraph" alt=""/></div>
<map name="warpcore_8c_ae29607b63a6bccf591386fbdabb944bf_cgraph" id="warpcore_8c_ae29607b63a6bccf591386fbdabb944bf_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#a26c31751f7bb602b01bf00077ebd362d" title="Close a warpcore socket. " alt="" coords="165,5,235,32"/><area shape="rect" id="node4" href="backend_8h.html#a0d3c16a0d0fbe62e779252b4f085abd3" title="Shut a warpcore netmap engine down cleanly. " alt="" coords="139,56,261,83"/><area shape="rect" id="node3" href="warpcore_8c.html#ade585dbd786f22b06727ff3a00d62ff7" title="Return a w_iov chain obtained via w_alloc() or w_rx() back to warpcore. " alt="" coords="335,5,396,32"/><area shape="rect" id="node5" href="arp_8c.html#a29b1c1f926ec4ca21f78e3dd0addce21" title="Free the ARP cache entries associated with engine w. " alt="" coords="310,56,421,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a26c31751f7bb602b01bf00077ebd362d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a warpcore socket. </p>
<p>This dequeues all data from <a class="el" href="structw__sock.html#ada65e4fbf06221e7fb73fabd1dd1be8c" title="w_iov chain containing incoming unread data. ">w_sock::iv</a> and w_sock::ov, i.e., data will <em>not</em> be placed in rings and sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to close. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a23">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a26">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_a26c31751f7bb602b01bf00077ebd362d_cgraph.png" border="0" usemap="#warpcore_8c_a26c31751f7bb602b01bf00077ebd362d_cgraph" alt=""/></div>
<map name="warpcore_8c_a26c31751f7bb602b01bf00077ebd362d_cgraph" id="warpcore_8c_a26c31751f7bb602b01bf00077ebd362d_cgraph">
<area shape="rect" id="node2" href="warpcore_8c.html#ade585dbd786f22b06727ff3a00d62ff7" title="Return a w_iov chain obtained via w_alloc() or w_rx() back to warpcore. " alt="" coords="125,5,187,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab31d23fb4fa64de58aef6c688ea6563a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a bound socket to a remote IP address and port. </p>
<p>Depending on the backend, this function may block until a MAC address has been resolved with ARP.</p>
<p>Calling <a class="el" href="warpcore_8c.html#ab31d23fb4fa64de58aef6c688ea6563a" title="Connect a bound socket to a remote IP address and port. ">w_connect()</a> will make subsequent <a class="el" href="warpcore_8c.html#a85274ecaf9a766de49a373c8dec27734" title="Loops over the w_iov structures in the chain c, sending them all over w_sock s. ">w_tx()</a> operations on the <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> enqueue payload data towards that destination. Unlike with the Socket API, <a class="el" href="warpcore_8c.html#ab31d23fb4fa64de58aef6c688ea6563a" title="Connect a bound socket to a remote IP address and port. ">w_connect()</a> can be called several times, which will re-bind a connected <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> and allows a server application to send data to multiple peers over a <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ip</td><td>Destination IPv4 address to bind to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Destination UDP port to bind to. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ping_8c-example.html#a9">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_ab31d23fb4fa64de58aef6c688ea6563a_cgraph.png" border="0" usemap="#warpcore_8c_ab31d23fb4fa64de58aef6c688ea6563a_cgraph" alt=""/></div>
<map name="warpcore_8c_ab31d23fb4fa64de58aef6c688ea6563a_cgraph" id="warpcore_8c_ab31d23fb4fa64de58aef6c688ea6563a_cgraph">
<area shape="rect" id="node2" href="backend_8h.html#af5df52522d52bfed04aa270094deaa78" title="Connect the given w_sock, using the netmap backend. " alt="" coords="139,107,263,133"/><area shape="rect" id="node3" href="arp_8c.html#a767793cec18e132d3875c6d374e8414f" title="Return the Ethernet MAC address for target IP address dip. " alt="" coords="312,107,411,133"/><area shape="rect" id="node4" href="arp_8c.html#a755a6595690a86527e7ef79847298d4a" title="Find the ARP cache entry associated with IPv4 address ip. " alt="" coords="459,5,570,32"/><area shape="rect" id="node5" href="backend_8h.html#acf9d923e03f757a9b81bd80293ce204a" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="478,56,551,83"/><area shape="rect" id="node6" href="eth_8c.html#a8cf5c7d93ad3a23d3b7b7787e0652653" title="Places an Ethernet frame into a TX ring. " alt="" coords="485,107,544,133"/><area shape="rect" id="node7" href="backend__netmap_8c.html#a8cd1929b5a30a3d3980feaaffb4c95ab" title="Push data placed in the TX rings via udp_tx() and similar methods out onto the link. " alt="" coords="477,157,552,184"/><area shape="rect" id="node8" href="backend__netmap_8c.html#a3f7d5dfbb0e11df581c3fcc6fe3015c1" title="Trigger netmap to make new received data available to w_rx(). " alt="" coords="477,208,552,235"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a07d8e5b61adc2c9fe1bd32c663a7e23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a419f620e2d1e04c34b248a6874004a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwarpcore.html">warpcore</a>* w_engine </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return warpcore engine serving <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The warpcore engine for <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ade585dbd786f22b06727ff3a00d62ff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain obtained via w_alloc() or <a class="el" href="warpcore_8c.html#a56a86a977786ce031b974f17536c1c4e" title="Iterates over any new data in the RX rings, appending them to the w_sock::iv socket buffers of the re...">w_rx()</a> back to warpcore. </p>
<p>The application must not use <code>v</code> after this call.</p>
<p>Do not make this , so the caller doesn't have to check v.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Warpcore engine. </td></tr>
    <tr><td class="paramname">c</td><td>Chain of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs to free. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a22">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a25">ping.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa83867b0dcc2a057772d7d6548a2be00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwarpcore.html">warpcore</a>* w_init </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>ifname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>rip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a warpcore engine on the given interface. </p>
<p>Ethernet and IPv4 source addresses and related information, such as the netmask, are taken from the active OS configuration of the interface. A default router, however, needs to be specified with <code>rip</code>, if communication over a WAN is desired.</p>
<p>Since warpcore relies on random() to generate random values, the caller should also set an initial seed with srandom() or srandomdev(). Warpcore does not do this, to allow the application control over the seed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifname</td><td>The OS name of the interface (e.g., "eth0"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rip</td><td>The default router to be used for non-local destinations. Can be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized warpcore engine. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a4">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a5">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_aa83867b0dcc2a057772d7d6548a2be00_cgraph.png" border="0" usemap="#warpcore_8c_aa83867b0dcc2a057772d7d6548a2be00_cgraph" alt=""/></div>
<map name="warpcore_8c_aa83867b0dcc2a057772d7d6548a2be00_cgraph" id="warpcore_8c_aa83867b0dcc2a057772d7d6548a2be00_cgraph">
<area shape="rect" id="node2" href="backend_8h.html#af7b0aa97cf956c2110e4ef0625e519fa" title="Initialize the warpcore netmap backend for engine w. " alt="" coords="115,5,210,32"/><area shape="rect" id="node3" href="plat_8h.html#af6b33b55cec0d2eedec73b51fdaef8ab" title="Return the Ethernet MAC address of network interface i. " alt="" coords="113,56,213,83"/><area shape="rect" id="node4" href="plat_8h.html#ababcbad22db97091f566216a5b2b849f" title="Return the MTU of network interface i. " alt="" coords="114,107,211,133"/><area shape="rect" id="node5" href="plat_8h.html#a84253d34fd3d0f7c55d4b319c4d2618b" title="Return the link status of network interface i. " alt="" coords="115,157,210,184"/><area shape="rect" id="node6" href="plat_8h.html#a5d7a687500042a6283402c4154bf453c" title="Return the link speed in Mb/s of network interface i. " alt="" coords="109,208,216,235"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a94286f6c75290edeb74f0a499aef1434"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t w_iov_chain_cnt </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain <code>c</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain to compute the payload length of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs in <code>c</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ping_8c-example.html#a24">ping.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a41497cbbe1bd11e4414a3c42d7f0c2ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t w_iov_chain_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total payload length of <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain <code>c</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> chain to compute the payload length of. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">off</td><td>Additional offset in each <code>buf</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the payload lengths of the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structs in <code>c</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a14">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a23">ping.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aae8a584953993df015ec032271c66f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t w_iov_max_len </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwarpcore.html">warpcore</a> *const&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structw__iov.html">w_iov</a> *const&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum size a given <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> may have for the given engine. </p>
<p>Basically, subtracts the header space and any offset specified when allocating the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> from the MTU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Warpcore engine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>The <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> in question.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum length of the data in a <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> for this engine. </dd></dl>

</div>
</div>
<a class="anchor" id="a56a86a977786ce031b974f17536c1c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a>* w_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterates over any new data in the RX rings, appending them to the <a class="el" href="structw__sock.html#ada65e4fbf06221e7fb73fabd1dd1be8c" title="w_iov chain containing incoming unread data. ">w_sock::iv</a> socket buffers of the respective <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> structures associated with a given sender IPv4 address and port. </p>
<p>Unlike with the Socket API, <a class="el" href="warpcore_8c.html#a56a86a977786ce031b974f17536c1c4e" title="Iterates over any new data in the RX rings, appending them to the w_sock::iv socket buffers of the re...">w_rx()</a> can append data to <a class="el" href="structw__sock.html#ada65e4fbf06221e7fb73fabd1dd1be8c" title="w_iov chain containing incoming unread data. ">w_sock::iv</a> chains <em>other</em> that that of the <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> passed as <code>s</code>. This is, because warpcore needs to drain the RX rings, in order to allow new data to be received by the NIC. It would be inconvenient to require the application to constantly iterate over all <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> sockets it has opened.</p>
<p>This means that although <a class="el" href="warpcore_8c.html#a56a86a977786ce031b974f17536c1c4e" title="Iterates over any new data in the RX rings, appending them to the w_sock::iv socket buffers of the re...">w_rx()</a> may return zero, because no new data has been received on <code>s</code>, it may enqueue new data into the <a class="el" href="structw__sock.html#ada65e4fbf06221e7fb73fabd1dd1be8c" title="w_iov chain containing incoming unread data. ">w_sock::iv</a> chains of other <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> for which the application would like to receive new data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chain of received w_iovs on <code>s</code>, or zero. Needs to be freed with <a class="el" href="warpcore_8c.html#ade585dbd786f22b06727ff3a00d62ff7" title="Return a w_iov chain obtained via w_alloc() or w_rx() back to warpcore. ">w_free()</a> by the caller. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a13">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a22">ping.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9de95626b431e277ef91938501adea5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct w_sock_chain* w_rx_ready </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structwarpcore.html">warpcore</a> *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a w_sock_chain containing all sockets with pending inbound data. </p>
<p>Caller needs to free() the returned value before the next call to <a class="el" href="warpcore_8c.html#a9de95626b431e277ef91938501adea5f" title="Return a w_sock_chain containing all sockets with pending inbound data. ">w_rx_ready()</a>. Data can be obtained via <a class="el" href="warpcore_8c.html#a56a86a977786ce031b974f17536c1c4e" title="Iterates over any new data in the RX rings, appending them to the w_sock::iv socket buffers of the re...">w_rx()</a> on each <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> in the chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Warpcore engine.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chain of <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> sockets that have incoming data pending. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a11">inetd.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a85274ecaf9a766de49a373c8dec27734"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void w_tx </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structw__sock.html">w_sock</a> *const&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structw__iov__chain.html">w_iov_chain</a> *const&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loops over the <a class="el" href="structw__iov.html" title="The I/O vector structure that warpcore uses at the center of its API. ">w_iov</a> structures in the chain <code>c</code>, sending them all over <a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> <code>s</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><a class="el" href="structw__sock.html" title="A warpcore socket. ">w_sock</a> to send data over. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">c</td><td><a class="el" href="structw__iov__chain.html" title="A chain of w_iov I/O vectors. ">w_iov_chain</a> to send. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="inetd_8c-example.html#a16">inetd.c</a>, and <a class="el" href="ping_8c-example.html#a14">ping.c</a>.</dd>
</dl>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="warpcore_8c_a85274ecaf9a766de49a373c8dec27734_cgraph.png" border="0" usemap="#warpcore_8c_a85274ecaf9a766de49a373c8dec27734_cgraph" alt=""/></div>
<map name="warpcore_8c_a85274ecaf9a766de49a373c8dec27734_cgraph" id="warpcore_8c_a85274ecaf9a766de49a373c8dec27734_cgraph">
<area shape="rect" id="node2" href="backend_8h.html#a538d48855851264a01c0a959476c40d4" title="Places the payload of v into an IPv4 UDP packet, and attempts to move it onto a TX ring..." alt="" coords="105,171,194,197"/><area shape="rect" id="node3" href="udp_8c.html#a5ff6c06e976086b17457bc7766bb8e0c" title="Sends a payload contained in a w_sock::ov via UDP. " alt="" coords="243,107,304,133"/><area shape="rect" id="node8" href="backend__netmap_8c.html#a8cd1929b5a30a3d3980feaaffb4c95ab" title="Push data placed in the TX rings via udp_tx() and similar methods out onto the link. " alt="" coords="517,259,592,285"/><area shape="rect" id="node4" href="arp_8c.html#a767793cec18e132d3875c6d374e8414f" title="Return the Ethernet MAC address for target IP address dip. " alt="" coords="352,157,451,184"/><area shape="rect" id="node10" href="ip_8h.html#a39e558260b696ca36c2a8af7b771b84a" title="Compute a pseudo checksum over three 32&#45;bit values. " alt="" coords="361,56,442,83"/><area shape="rect" id="node11" href="ip_8h.html#a7d5fa0202a9ab96e38a5769d8c6177f2" title="Compute the Internet checksum over buffer buf of length len. " alt="" coords="515,5,594,32"/><area shape="rect" id="node12" href="ip_8c.html#a2165f6158886310cb7d3cdb1e0b5646d" title="IPv4 transmit processing for the w_iov v of length len. " alt="" coords="376,107,427,133"/><area shape="rect" id="node5" href="arp_8c.html#a755a6595690a86527e7ef79847298d4a" title="Find the ARP cache entry associated with IPv4 address ip. " alt="" coords="499,208,610,235"/><area shape="rect" id="node6" href="backend_8h.html#acf9d923e03f757a9b81bd80293ce204a" title="Return a spare w_iov from the pool of the given warpcore engine. " alt="" coords="518,107,591,133"/><area shape="rect" id="node7" href="eth_8c.html#a8cf5c7d93ad3a23d3b7b7787e0652653" title="Places an Ethernet frame into a TX ring. " alt="" coords="525,56,584,83"/><area shape="rect" id="node9" href="backend__netmap_8c.html#a3f7d5dfbb0e11df581c3fcc6fe3015c1" title="Trigger netmap to make new received data available to w_rx(). " alt="" coords="517,157,592,184"/></map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac5f4812d2c339c6d0fa6e591bf555caf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct w_engines engines = SLIST_HEAD_INITIALIZER(engines)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A global list of netmap engines that have been initialized for different interfaces. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 23 2017 14:13:40 for warpcore by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
